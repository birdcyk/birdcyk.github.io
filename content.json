{"pages":[{"title":"about","text":"关于我的","link":"/about/index.html"}],"posts":[{"title":"redis面试要点","text":"特点 支持多种类型的数据，string hash set list 数据容量容量收到物理内存的限制，不能进行海量数据存储 数据都保存在内存中，因此操作速度快。 支持事务 单进程单线程，通过队列的方式来解决多线程同时操作redis。Redis集群主从概念。至少三台redis 才能组成一个集群，因为集群是通过选举机制来确认主从关系。 在集群中，可以通过主redis进行些操作，从的负责查操作。 集群同步： 是通过心跳包的方式，一段时间进行数据同步一次。 Redis的持久化RDB 原理: RDB 是通过fork子进程，将数据写入临时文件，在最终的时候将临时文件覆盖掉备份文件，用二进制压缩存储。 优点 RDB 方式只会有一个备份文件，恢复容易 RDB fork子进程对数据进行备份，效率最大化，避免了服务进程的IO读写的效率 RDB 相对于AOF 来说， 如果数据集很大，RDB的启动效率会更高 缺点 RDB 属于定时持久化，在持久化之前出现拓机等问题，会造成部分数据无法恢复的问题。 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒(可以理解为在fork子进程执行的时候，阻塞了服务进程)AOF 原理 AOF 是对删除更新写入操作以日志的形似记录，查询的操作不会被记录。以文本的方式记录，可以打开文件看到详细的操作记录 优点 数据记录格式清晰，易于理解。 数据记录是通过追加的方式，每次的记录会append后面。 AOF 三种策略，每秒同步，每次修改同步与不同步。 这种同步机制，可以很少的避免拓机带来的大量数据丢失问题。每秒同步策略是异步的。 特殊情况说明，如果说在同步到一半的时候拓机，在恢复的之前，可通过redis-check-aof工具来帮助我们解决数据 一致性的问题。只会造成少量数据损失。与RDB 一点不同的是，每次都会修改都会被同步。而RDB只会在同步的时候，对最终数据进行同步。 缺点 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 总结二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了 Redis 与 memcache的区别 memcache 把数据也是放在内存中，如果出现宕机或者断电，数据不可恢复。Redis可持久化到硬盘 memcache只支持简单的string类型，而redis支持丰富的数据类型。 设置value值大小不同，redis最大可以达到1GB，而memcache只有1MB案例场景分析MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰no-enviction（驱逐）：禁止驱逐数据 redis分布式锁主要是通过redis提供的setNX来实现，不存在则放入。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？会造成redis阻塞，命令执行完毕才会恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 如果有大量的key需要设置同一时间过期，一般需要注意什么如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些 Redis的容灾策略 开启主从备份 master上不开启任何备份，在slave上开启备份。 master挂掉只后，修改slave为master Redis的高级进阶 读写分离 在master上只做写操作，slave上只做读的操作。 slave上可以拓展，读性能可达到线性提升。 主从热备 在读写分离模式中，保证稳定性，可以使用两台master做主从热备，保证数据的安全性 redis数据分片。 每一台机器都可以看做时一个master，每台机器只根据规则保存一类值。且每台机器都看做时一个master与多个slave Redis事务通过multi命令来开启事务，随后的一系列操作都会被添加到事务队列中，直到执行了exec才会开始执行事务。 同时也可以通过discard来清空事务队列，取消事务的执行。 若在事务执行exec操作之前，其他值发生了变化？ 可以通过watch指令，来观察一组值，然后开启事务，若在watch之后，exec之前被watch的键发生了变化，则会取消事务的执行。 Redis SetNX为什么能实现分布式锁因为Redis是单进程单线程的，它能够保证操作的原子性与有序性。","link":"/2019/03/10/redis面试要点/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"面试","slug":"面试","link":"/tags/面试/"}],"categories":[{"name":"java面试","slug":"java面试","link":"/categories/java面试/"}]}